#!/bin/sh
# ----------------------------------------------------------------------
#  USER INTERFACE DRIVER
#
#  This driver program loads a tool description from a tool.xml file,
#  and produces a user interface automatically to drive an application.
#  The user can set up input, click and button to launch a tool, and
#  browse through output.
#
#  RUN AS FOLLOWS:
#    driver ?-tool <toolfile>?
#
#  If the <toolfile> is not specified, it defaults to "tool.xml" in
#  the current working directory.
#
# ======================================================================
#  AUTHOR:  Michael McLennan, Purdue University
#  Copyright (c) 2004  Purdue Research Foundation, West Lafayette, IN
# ======================================================================
#\
exec wish "$0" $*
# ----------------------------------------------------------------------
# wish executes everything from here on...

package require Rappture

option add *MainWin.mode desktop startupFile
option add *MainWin.borderWidth 0 startupFile
option add *MainWin.anchor fill startupFile

# "web site" look
option add *MainWin.bgScript {
    rectangle 0 0 200 <h> -outline "" -fill #5880BB
    rectangle 200 0 300 <h> -outline "" -fill #425F8B
    rectangle 300 0 <w> <h> -outline "" -fill #324565
} startupFile

# "clean" look
option add *MainWin.bgScript "" startupFile
option add *MainWin.bgColor white startupFile
option add *Tooltip.background white
option add *Editor.background white
option add *Gauge.textBackground white
option add *TemperatureGauge.textBackground white
option add *Switch.textBackground white
option add *Progress.barColor #ffffcc

switch $tcl_platform(platform) {
    unix - windows {
        event add <<PopupMenu>> <ButtonPress-3>
    }
    macintosh {
        event add <<PopupMenu>> <Control-ButtonPress-1>
    }
}

# fix the "grab" command to support a stack of grab windows
Rappture::grab::init

#
# Process command line args to get the names of files to load...
#
Rappture::getopts argv params {
    value -tool tool.xml
}

# open the XML file containing the tool parameters
if {![file exists $params(-tool)]} {
    puts stderr "can't find tool \"$params(-tool)\""
    exit 1
}
set xmlobj [Rappture::library $params(-tool)]

set installdir [file dirname $params(-tool)]
if {"." == $installdir} {
    set installdir [pwd]
}

set tool [Rappture::Tool ::#auto $xmlobj $installdir]

# ----------------------------------------------------------------------
# INITIALIZE THE DESKTOP CONNECTION
#
# If there's a SESSION ID, then this must be running within the
# nanoHUB.  Try to initialize the server handling the desktop
# connection.
# ----------------------------------------------------------------------
Rappture::filexfer::init

# ----------------------------------------------------------------------
# MAIN WINDOW
# ----------------------------------------------------------------------
wm withdraw .
Rappture::MainWin .main -borderwidth 0
.main configure -title [$tool xml get tool.title]
wm withdraw .main

#
# The main window has a pager that acts as a notebook for the
# various parts.  This notebook as at least two pages--an input
# page and an output (analysis) page.  If there are <phase>'s
# for input, then there are more pages in the notebook.
#
set win [.main component app]
Rappture::Postern $win.postern
pack $win.postern -side bottom -fill x

Rappture::Pager $win.pager
pack $win.pager -expand yes -fill both

set phases [$tool xml children -type phase input]
if {[llength $phases] > 0} {
    set plist ""
    foreach name $phases {
        lappend plist input.$name
    }
    set phases $plist
} else {
    set phases input
}

foreach comp $phases {
    set title [$tool xml get $comp.about.label]
    if {$title == ""} {
        set title "Input #auto"
    }
    $win.pager insert end -name $comp -title $title

    #
    # Build the page of input controls for this phase.
    #
    set f [$win.pager page $comp]
    Rappture::Page $f.cntls $tool $comp
    pack $f.cntls -expand yes -fill both
}

# ----------------------------------------------------------------------
# OUTPUT AREA
# ----------------------------------------------------------------------
$win.pager insert end -name analyzer -title "Run"
set f [$win.pager page analyzer]
$win.pager page analyzer -command [list $f.analyze simulate -ifneeded]

Rappture::Analyzer $f.analyze $tool -simcontrol auto
pack $f.analyze -expand yes -fill both

$tool notify add analyzer * [list $f.analyze reset]

# ----------------------------------------------------------------------
# Finalize the arrangement
# ----------------------------------------------------------------------
if {[llength [$win.pager page]] == 2} {
    set style [$xmlobj get tool.layout]
    set screenw [winfo screenwidth .]

    update idletasks
    set w0 [winfo reqwidth [$win.pager page @0]]
    set w1 [winfo reqwidth [$win.pager page @1]]

    # if only two windows and they're small enough, put them up side-by-side
    if {$w0+$w1 < $screenw && $style != "wizard"} {
        $win.pager configure -arrangement side-by-side
        $f.analyze configure -holdwindow [$win.pager page @0]

        set type [$tool xml get tool.control]
        if {$type == ""} {
            set type [$tool xml get tool.control.type]
        }

        if {$type == "auto"} {
            # in "auto" mode, we don't need a simulate button
            $f.analyze configure -simcontrol off
        } else {
            # not in "auto" mode but side-by-side, we always need the button
            $f.analyze configure -simcontrol on
        }
    }
}
wm deiconify .main
