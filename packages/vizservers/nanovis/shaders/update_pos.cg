/* -*- mode: c++; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
 * ======================================================================
 *  AUTHOR:  Wei Qiao <qiaow@purdue.edu>
 *           Purdue Rendering and Perceptualization Lab (PURPL)
 *
 *  Copyright (c) 2004-2006  Purdue Research Foundation
 *
 *  See the file "license.terms" for information on usage and
 *  redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 * ======================================================================
 */

// update positions based on velocity

#include "common.cg"

float4 main(in float2 uv : TEXCOORD0,
            uniform samplerRECT pos_tex,
            uniform samplerRECT init_pos_tex,
            uniform sampler3D vel_tex,
            // uniform sampler1D tf_tex,
            uniform float timestep,
            uniform float max,
            uniform float mode,
            uniform float3 scale) : COLOR
{
    float4 ret;
    /*
      if (mode == 0) {
          float4 pos = texRECT(pos_tex, uv);
          float4 vel = tex3D(vel_tex, pos.xyz);
          ret.xyz = tex1D(tf_tex, vel.x).xyz;
          ret.w = 1;
      } else {
    */
    // get previous position
    float4 pos = texRECT(pos_tex, uv);
    float time = pos.w;

#ifdef EXPIRE
    time -= timestep;

    // Lifetime ended?
    if (time < 0) {
        return texRECT(init_pos_tex, uv);
    }
#endif

    //reconstruct negative value
    float4 vel = float4(tex3D(vel_tex, pos.xyz).yzw, 0) - float4(0.5, 0.5, 0.5, 0.0f);
    vel = vel * (2 * max);
    //vel *= float4(scale, 1);
    ret = pos + (vel * timestep);

    //not drawing if the particle is out of bound
    if (ret.x < 0 || ret.x > 1 || ret.y < 0 || ret.y > 1 || ret.z < 0 || ret.z > 1) {
        ret = texRECT(init_pos_tex, uv);
    } else {
        ret.w = time;
    }
//    }

    return ret;
}
