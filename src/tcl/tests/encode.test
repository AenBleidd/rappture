# Commands covered: 
#   Rappture::encoding::is
#   Rappture::encoding::encode
#   Rappture::encoding::decode
#
# This file contains a collection of tests for one of the Rappture Tcl
# commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# ======================================================================
# AUTHOR:  Derrick Kearney, Purdue University
# Copyright (c) 2004-2007  Purdue Research Foundation
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.


if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    package require Rappture
    namespace import -force ::tcltest::*
}

#----------------------------------------------------------
#----------------------------------------------------------
# is command
# Rappture::encoding::is binary <string>
#----------------------------------------------------------
test is-1.0.1 {Rappture::encoding::is, 0 arguments} {
    list [catch {Rappture::encoding::is} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::is binary <string>"}}

test is-1.1.1 {Rappture::encoding::is, 1 incomplete subcommand} {
    list [catch {Rappture::encoding::is binary} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::is binary <string>"}}

test is-1.1.2 {Rappture::encoding::is, 1 subcommand w/ string} {
    list [catch {Rappture::encoding::is binary "hi"} msg] $msg
} {0 no}

test is-1.1.3 {Rappture::encoding::is, 1 subcommand w/ string} {
    set h "H4sIAAAAAAAAA8vIBACsKpPYAgAAAA=="
    set b [Rappture::encoding::decode -as b64 $h]
    list [catch {Rappture::encoding::is binary $b} msg] $msg
} {0 yes}

test is-1.2.0 {Rappture::encoding::is, 1 invalid subcommand} {
    list [catch {Rappture::encoding::is binaryy "hi"} msg] $msg
} {1 {bad option "binaryy": should be binary}}

test is-1.2.1 {Rappture::encoding::is, too many arguments} {
    list [catch {Rappture::encoding::is binary binary "hi"} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::is binary <string>"}}

#----------------------------------------------------------
#----------------------------------------------------------
# encode command
# Rappture::encoding::encode ?-as z|b64? ?-no-header? <string>
#----------------------------------------------------------

test encode-2.0.0 {Rappture::encoding::encode, 0 arguments} {
    list [catch {Rappture::encoding::encode} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::encode ?-as z|b64|zb64? ?-no-header? <string>"}}

test encode-2.1.0 {Rappture::encoding::encode, ascii string argument} {
    list [catch {Rappture::encoding::encode "hi"} msg] $msg
} {0 {@@RP-ENC:zb64
H4sIAAAAAAAAA8vIBACsKpPYAgAAAA==
}}

test encode-2.1.1 {Rappture::encoding::encode, binary string argument}  {
    set h "H4sIAAAAAAAAA8vIBACsKpPYAgAAAA=="
    set b [Rappture::encoding::decode -as b64 $h]
    list [catch {Rappture::encoding::encode $b} msg] $msg
} {0 {@@RP-ENC:zb64
H4sIAAAAAAAAA5Pv5mAAA+bTJ1gY1mhNvsEE5AAAFVLsvBYAAAA=
}}

test encode-2.2.0 {Rappture::encoding::encode, -as flag blank value} {
    list [catch {Rappture::encoding::encode -as} msg] $msg
} {1 {bad value "": should be one of z, b64, zb64}}

test encode-2.2.1 {Rappture::encoding::encode, -as flag bad value } {
    list [catch {Rappture::encoding::encode -as zz} msg] $msg
} {1 {bad value "zz": should be one of z, b64, zb64}}

test encode-2.2.2 {Rappture::encoding::encode, -as flag correct value z} {
    list [catch {Rappture::encoding::encode -as z} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::encode ?-as z|b64|zb64? ?-no-header? <string>"}}

test encode-2.2.3 {Rappture::encoding::encode, -as z w/ string} {
    list [catch {Rappture::encoding::encode -as z "hi"} msg] $msg
} {0 {@@RP-ENC:z
\xCB\xC8\x3F\x2A\x3F\xD8}}

test encode-2.2.4 {Rappture::encoding::encode, -as b64 w/ string} {
    list [catch {Rappture::encoding::encode -as b64 "hi"} msg] $msg
} {0 {@@RP-ENC:b64
aGk=
}}

#----------------------------------------------------------
#----------------------------------------------------------
# decode command
# Rappture::encooding::decode <string>
#----------------------------------------------------------

test decode-3.0.0 {Rappture::encoding::decode, 0 arguments} {
    list [catch {Rappture::encoding::decode} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::decode ?-as z|b64|zb64? <string>"}}

test decode-3.1.0 {Rappture::encoding::decode, 1 arg, b64 encoded} {
    set h "aGk="
    list [catch {Rappture::encoding::decode $h} msg] $msg
} {0 aGk=}

test decode-3.1.1 {Rappture::encoding::decode, 1 arg, zb64 encoded} {
    set h "@@RP-ENC:zb64\nH4sIAAAAAAAAA8vIBACsKpPYAgAAAA=="
    list [catch {Rappture::encoding::decode $h} msg] $msg
} {0 hi}

test decode-3.1.2 {Rappture::encoding::decode, 2 args} {
    list [catch {Rappture::encoding::decode "hi" "bye"} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::decode ?-as z|b64|zb64? <string>"}}

test decode-3.2.0 {Rappture::encoding::decode, -as flag, no value} {
    list [catch {Rappture::encoding::decode -as} msg] $msg
} {1 {bad value "": should be one of z, b64, zb64}}

test decode-3.2.1 {Rappture::encoding::decode, -as flag, bad value} {
    list [catch {Rappture::encoding::decode -as zz} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::decode ?-as z|b64|zb64? <string>"}}

test decode-3.2.2 {Rappture::encoding::decode, -as flag, zb64 w/ string} {
    set h "@@RP-ENC:zb64\nH4sIAAAAAAAAA8vIBACsKpPYAgAAAA=="
    list [catch {Rappture::encoding::decode -as z $h} msg] $msg
} {0 hi}

test decode-3.2.3 {Rappture::encoding::decode, -as flag, b64 w/ string} {
    set h "@@RP-ENC:b64\naGk="
    list [catch {Rappture::encoding::decode -as b64 $h} msg] $msg
} {0 hi}


::tcltest::cleanupTests
return

