// Copyright (c) 2004-2005 Lutz Latta
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// Velocity change operations.
#include "velocityOps.cg"

// Uniform parameters influencing velocity.
uniform float3 _SphereCenter;
uniform samplerRECT _TerrainTexture : register(s2);
uniform samplerRECT _FlowFieldTexture : register(s3);
uniform float3 _LocalAttractorPosition[4];

float3 advanceVelocity(float3 _Velocity, float3 _Position, float _TimeStep)
{
	float3 gravity = float3(0, -.01, 0);
	
	float3 acceleration = gravity;

	//acceleration += localAttractor(_Position, 
	//	getClosestPointOnLine(_LocalAttractorPosition[0], _LocalAttractorPosition[1], _Position),
	//	0.05, 0.2);
	//acceleration += localAttractor(_Position, _LocalAttractorPosition[0], 0.02, 0.4);
	//acceleration += localAttractor(_Position, _LocalAttractorPosition[1], 0.02, 0.02);
	//acceleration += localRepulsor(_Position, _LocalAttractorPosition[2], 0.02, 0.1);
	//acceleration += localRepulsor(_Position, _LocalAttractorPosition[3], 0.02, 0.1);
	//acceleration += flowFieldVector(_Position, _FlowFieldTexture, float2(512, 512),
	//	float3(4, 4, 4), float3(256, 0, 256), 0.01);

	float3 velocity = _Velocity + _TimeStep * acceleration;
	
	//velocity = lerp(velocity, flowFieldVector(_Position, _FlowFieldTexture, float2(512, 512),
	//	float3(4, 4, 4), float3(256, 0, 256), 1), 0.2);
	//velocity = length(velocity) * normalize(flowFieldVector(_Position, _FlowFieldTexture, float2(512, 512),
	//	float3(4, 4, 4), float3(256, 0, 256), 1));

	//spiral(velocity, _TimeStep, normalize(_LocalAttractorPosition[0] - _LocalAttractorPosition[1]), .3);

	//dampen(velocity, 1.1);
	//undampen(velocity, 1.01);

	floorConstraint(velocity, _Position, 0, 0.4, 0.1, 0.01);
	sphereConstraint(velocity, _Position, _SphereCenter, 1, 0.3, 0.7, 0.01);
	//terrainConstraint(velocity, _Position, _TerrainTexture, float2(128, 128),
	//	float3(4, 4, 4), float3(64, 0, 64), 0.02, 0.7, 0.01);
	
	return velocity;
}

float4 main
(
	float2 _TexCoord : TEXCOORD0,
	uniform samplerRECT _VelocityTexture : register(s0),
	uniform samplerRECT _PositionTexture : register(s1),
	uniform float _TimeStep
) : COLOR
{
	float3 velocity = (float3)texRECT(_VelocityTexture, _TexCoord);
	float3 position = (float3)texRECT(_PositionTexture, _TexCoord);
	
	return float4(advanceVelocity(velocity, position, _TimeStep), 0);
}

float4 mainInitialization
(
	float3 _VelocityInit : TEXCOORD0,
	float3 _PositionInit : TEXCOORD1,
	float _TimeStep : TEXCOORD2
) : COLOR
{
	return float4(advanceVelocity(_VelocityInit, _PositionInit, _TimeStep), 0);
}
