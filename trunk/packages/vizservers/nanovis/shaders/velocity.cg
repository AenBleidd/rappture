/* -*- mode: c++; c-basic-offset: 4; indent-tabs-mode: nil -*- */
// Copyright (c) 2004-2005 Lutz Latta
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// Velocity change operations.
//#include "velocityOps.cg"

// Uniform parameters influencing velocity.
uniform float3 _SphereCenter;
uniform samplerRECT _TerrainTexture : register(s2);
uniform samplerRECT _FlowFieldTexture : register(s3);
uniform float3 _LocalAttractorPosition[4];

float3 advanceVelocity(float3 _Velocity, float3 _Position, float _TimeStep)
{
    float3 gravity = float3(0, -.01, 0);

    float3 acceleration = gravity;

    //acceleration += 
    //    localAttractor(_Position, 
    //                   getClosestPointOnLine(_LocalAttractorPosition[0],
    //                                         _LocalAttractorPosition[1], _Position), 0.05, 0.2);
    //acceleration += localAttractor(_Position, _LocalAttractorPosition[0], 0.02, 0.4);
    //acceleration += localAttractor(_Position, _LocalAttractorPosition[1], 0.02, 0.02);
    //acceleration += localRepulsor(_Position, _LocalAttractorPosition[2], 0.02, 0.1);
    //acceleration += localRepulsor(_Position, _LocalAttractorPosition[3], 0.02, 0.1);
    //acceleration += flowFieldVector(_Position, _FlowFieldTexture, float2(512, 512),
    //                                float3(4, 4, 4), float3(256, 0, 256), 0.01);

    float3 velocity = _Velocity + _TimeStep * acceleration;

    //velocity = lerp(velocity, flowFieldVector(_Position, _FlowFieldTexture, float2(512, 512),
    //                                          float3(4, 4, 4), float3(256, 0, 256), 1), 0.2);
    //velocity = length(velocity) * normalize(flowFieldVector(_Position, _FlowFieldTexture, float2(512, 512),
    //                                                        float3(4, 4, 4), float3(256, 0, 256), 1));

    //spiral(velocity, _TimeStep, normalize(_LocalAttractorPosition[0] - _LocalAttractorPosition[1]), .3);

    //dampen(velocity, 1.1);
    //undampen(velocity, 1.01);

    floorConstraint(velocity, _Position, 0, 0.4, 0.1, 0.01);
    sphereConstraint(velocity, _Position, _SphereCenter, 1, 0.3, 0.7, 0.01);
    //terrainConstraint(velocity, _Position, _TerrainTexture, float2(128, 128),
    //	                float3(4, 4, 4), float3(64, 0, 64), 0.02, 0.7, 0.01);

    return velocity;
}

float4 main(float2 _TexCoord : TEXCOORD0,
            uniform samplerRECT _VelocityTexture : register(s0),
            uniform samplerRECT _PositionTexture : register(s1),
            uniform float _TimeStep) : COLOR
{
    float3 velocity = (float3)texRECT(_VelocityTexture, _TexCoord);
    float3 position = (float3)texRECT(_PositionTexture, _TexCoord);

    return float4(advanceVelocity(velocity, position, _TimeStep), 0);
}

float4 mainInitialization(float3 _VelocityInit : TEXCOORD0,
                          float3 _PositionInit : TEXCOORD1,
                          float _TimeStep : TEXCOORD2) : COLOR
{
    return float4(advanceVelocity(_VelocityInit, _PositionInit, _TimeStep), 0);
}
