/* -*- mode: c++; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
 * Copyright (c) 2004-2013  HUBzero Foundation, LLC
 *
 * Authors:
 *   Wei Qiao <qiaow@purdue.edu>
 */

#include "common.cg"

/*
 * zincblende shading fragment program
 * 
 * renderParams:
 *   x: sample distance ratio (0 = single slice)
 *   y: isosurface flag (opacity scaling on/off)
 *   z: opacity scale
 */
PixelOut main(v2f IN, 
              uniform sampler1D tf,
              uniform sampler3D volumeA, 
              uniform sampler3D volumeB, 
              uniform float4 cellSize,
              uniform float4 renderParams)

{
    PixelOut OUT;

    float4 texcoord = IN.TexCoord;
    float4 twice_cell_size = cellSize * 2.0;

    // volumeA : outer
    // volumeB : inner
    float4 texcoord_2 = texcoord + float4(twice_cell_size.x, 0,                 twice_cell_size.z, 0);
    float4 texcoord_3 = texcoord + float4(0,                 twice_cell_size.y, twice_cell_size.z, 0);
    float4 texcoord_4 = texcoord + float4(twice_cell_size.x, twice_cell_size.y, 0, 0); 
    float4 voxel_corner = tex3D(volumeB, texcoord) + tex3D(volumeA, texcoord - cellSize);
    float4 voxel_face_center_2 = tex3D(volumeB, texcoord_2) + tex3D(volumeA, texcoord_2 - cellSize);
    float4 voxel_face_center_3 = tex3D(volumeB, texcoord_3) + tex3D(volumeA, texcoord_3 - cellSize);
    float4 voxel_face_center_4 = tex3D(volumeB, texcoord_4) + tex3D(volumeA, texcoord_4 - cellSize);

    float sample = (voxel_corner.x + voxel_face_center_2.y + voxel_face_center_3.z + voxel_face_center_4.w) * 0.125;
    /*
      float4 texcoord_a = texcoord - float4(twice_cell_size.x, twice_cell_size.y, 0, 0);
      float4 texcoord_b = texcoord - float4(twice_cell_size.x, 0, twice_cell_size.z, 0);
      float4 texcoord_c = texcoord - float4(0, twice_cell_size.y, twice_cell_size.z, 0); 
	
      float4 voxel_corner = tex3D(volumeA, texcoord) + tex3D(volumeB, texcoord - cellSize);
      float4 voxel_face_center_a = tex3D(volumeA, texcoord_a) + tex3D(volumeB, texcoord_a - cellSize);
      float4 voxel_face_center_b = tex3D(volumeA, texcoord_b) + tex3D(volumeB, texcoord_b - cellSize);
      float4 voxel_face_center_c = tex3D(volumeA, texcoord_c) + tex3D(volumeB, texcoord_c - cellSize);
      //combine 8 sampling results
      float sample = (voxel_corner.x + voxel_face_center_a.y + voxel_face_center_b.z + voxel_face_center_c.w) * 0.125;
    */

    //sample transfer function texture
    float4 color = tex1D(tf, sample);

    if (renderParams.x == 0.0) {
        //If single slice render, only flat shading, completely opaque.
        color.w = 1;
    } else {
        //regular volume rendering, we do FLAT SHADING 
        //since all 4 components of the volume texture has been used to store orbital data,
        //there is no room to store normal vector. If we really need PHONG shading we have to pass more volumes to
        //the shader. We might add this later.

        // Opacity scaling: equivalent to scaling transfer function
        color.w = color.w * renderParams.z;
        // Apply opacity correction for ratio of current sample distance
        // to data set sample distance
        color.w = (1.0 - pow((1.0 - color.w), renderParams.x));
    }

    OUT.Color = color;
    return OUT;
}
