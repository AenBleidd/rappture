/* -*- mode: c++; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
 * ======================================================================
 *  AUTHOR:  Wei Qiao <qiaow@purdue.edu>
 *           Purdue Rendering and Perceptualization Lab (PURPL)
 *
 *  Copyright (c) 2004-2006  Purdue Research Foundation
 *
 *  See the file "license.terms" for information on usage and
 *  redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 * ======================================================================
 */

#include "common.cg"

/*
 * render one volume 
 *
 * renderParameters:
 *   x: number of slices
 *   y: opacity scale (1-21)
 *   z: diffuse coefficient
 *   w: specular exponent
 * options:
 *   y = isosurface flag (opacity scaling on/off)
 */
PixelOut main(v2f IN,
              uniform sampler3D volume,
              uniform sampler1D tf,
              uniform float4x4 modelViewInv,
              uniform float4x4 modelView,
              uniform float4 renderParameters,
              uniform float4 options)
{
    PixelOut OUT;
    float4 tex_coord = mul(modelViewInv, IN.TexCoord);
    float4 sample = tex3D(volume, tex_coord.xyz);

    //sample the transfer function texture
    float4 color = tex1D(tf, sample.x);

    if (renderParameters.x < 0.5) {
        //If single slice render, only flat shading, completely opaque.
        color.w = 1;
    } else {
        //regular volume rendering, we do PHONG SHADING 
        //lighting parameters
#if 1
        float3 normal;
        float diffuse, specular;
        if (dot(sample.yzw, sample.yzw) < 5.0e-5) {
            diffuse = 0;
            specular = 0;
        } else {
            normal = normalize(sample.yzw * 2.0 - 1.0);
            float3 light_vector = normalize(IN.Light);
            float3 eye_vector = normalize(IN.EyeVector);
            float3 half_vector = normalize(eye_vector+light_vector);

            //lighting computation
#ifndef LIGHT_TWO_SIDE
            float normal_dot_light = max(dot(normal, light_vector), 0);
            float normal_dot_half = max(dot(normal, half_vector), 0);
#else
            float normal_dot_light = dot(normal, light_vector);
            if (normal_dot_light < 0.0) {
                normal_dot_light = dot(-normal, light_vector);
            }
            float normal_dot_half = dot(normal, half_vector);
            if (normal_dot_half < 0.0) {
                normal_dot_half = dot(-normal, half_vector);
            }
#endif
            diffuse = normal_dot_light * renderParameters.z;
            //specular = pow(normal_dot_half, renderParameters.w)*(1-ambient-diffuse);
            if (diffuse > 1.0e-6) 
                specular = pow(normal_dot_half, 90.)*0.3;
            else
                specular = 0.0;
        }
        float ambient = max(.2, 1.0 - renderParameters.z);

        float lighting = ambient + diffuse + specular;
        color.xyz = color.xyz * ambient + color.xyz * diffuse + float3(specular);
#else
        if (dot(sample.yzw, sample.yzw) < 5.0e-5) {
            color.xyz = float3(0);
        } else {
            color.xyz = normalize(sample.yzw);
        }
#endif

        if (options.y < 0.5) {
            //opacity is modulated by the number of total slices
            //to avoid very opaque volume when number of slices is high
            // renderParameters.x = number of slices
            // renderParameters.y = opacity scale (1-21)
            color.w = color.w * 0.2 * renderParameters.y/renderParameters.x;

            // INSOO (iso)
            //opacity is modulated by the number of total slices
            //color.w = color.w * renderParameters.y/renderParameters.x * 0.2;
        }
    }

  OUT.Color = min(max(color, 0.0), 1.0);

  return OUT;
}
