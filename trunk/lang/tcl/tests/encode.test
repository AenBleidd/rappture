# Commands covered: 
#   Rappture::encoding::is
#   Rappture::encoding::encode
#   Rappture::encoding::decode
#
# This file contains a collection of tests for one of the Rappture Tcl
# commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# ======================================================================
# AUTHOR:  Derrick Kearney, Purdue University
# Copyright (c) 2004-2007  Purdue Research Foundation
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.


if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    package require Rappture
    namespace import -force ::tcltest::*
}

#----------------------------------------------------------
#----------------------------------------------------------
# is command
# Rappture::encoding::is binary <string>
#----------------------------------------------------------
test is-1.0.1 {Rappture::encoding::is, 0 arguments} {
    list [catch {Rappture::encoding::is} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::is binary|encoded <string>"}}

test is-1.1.1 {Rappture::encoding::is, 1 incomplete subcommand} {
    list [catch {Rappture::encoding::is binary} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::is binary|encoded <string>"}}

test is-1.1.2 {Rappture::encoding::is, 1 subcommand w/ string} {
    list [catch {Rappture::encoding::is binary "hi"} msg] $msg
} {0 no}

test is-1.1.3 {Rappture::encoding::is, 1 subcommand w/ string} {
    set h "H4sIAAAAAAAAA8vIBACsKpPYAgAAAA=="
    set b [Rappture::encoding::decode -as b64 $h]
    list [catch {Rappture::encoding::is binary $b} msg] $msg
} {0 yes}

test is-1.2.0 {Rappture::encoding::is, 1 invalid subcommand} {
    list [catch {Rappture::encoding::is binaryy "hi"} msg] $msg
} {1 {bad option "binaryy": should be binary or encoded}}

test is-1.2.1 {Rappture::encoding::is, too many arguments} {
    list [catch {Rappture::encoding::is binary binary "hi"} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::is binary|encoded <string>"}}

test is-1.2.2 {Rappture::encoding::is, with an embedded null} {
    list [catch {Rappture::encoding::is binary "x\000x"} msg] $msg
} {0 yes}

test is-1.3.1 {Rappture::encoding::is, encoded subcommand w/ false string} {
    list [catch {Rappture::encoding::is encoded "hi"} msg] $msg
} {0 no}

test is-1.3.2 {Rappture::encoding::is, encoded b64 flag and extra string} {
    set h "@@RP-ENC:b64\nH4sIAAAAAAAAA8vIBACsKpPYAgAAAA=="
    list [catch {Rappture::encoding::is encoded $h} msg] $msg
} {0 yes}

test is-1.3.3 {Rappture::encoding::is, encoded zb64 flag and extra string} {
    set h "@@RP-ENC:zb64\nH4sIAAAAAAAAA8vIBACsKpPYAgAAAA=="
    list [catch {Rappture::encoding::is encoded $h} msg] $msg
} {0 yes}

test is-1.3.4 {Rappture::encoding::is, encoded z flag and extra string} {
    set h "@@RP-ENC:z\nH4sIAAAAAAAAA8vIBACsKpPYAgAAAA=="
    list [catch {Rappture::encoding::is encoded $h} msg] $msg
} {0 yes}

test is-1.3.5 {Rappture::encoding::is, encoded z flag newline no string} {
    set h "@@RP-ENC:z\n"
    list [catch {Rappture::encoding::is encoded $h} msg] $msg
} {0 yes}

test is-1.3.6 {Rappture::encoding::is, encoded b64 flag newline no string} {
    set h "@@RP-ENC:b64\n"
    list [catch {Rappture::encoding::is encoded $h} msg] $msg
} {0 yes}

test is-1.3.7 {Rappture::encoding::is, encoded zb64 flag newline no string} {
    set h "@@RP-ENC:zb64\n"
    list [catch {Rappture::encoding::is encoded $h} msg] $msg
} {0 yes}

test is-1.3.7 {Rappture::encoding::is, encoded z flag no newline no string} {
    set h "@@RP-ENC:zb64"
    list [catch {Rappture::encoding::is encoded $h} msg] $msg
} {0 no}

test is-1.3.8 {Rappture::encoding::is, encoded b64 flag no newline no string} {
    set h "@@RP-ENC:b64"
    list [catch {Rappture::encoding::is encoded $h} msg] $msg
} {0 no}

test is-1.3.9 {Rappture::encoding::is, encoded zb64 flag no newline no string} {
    set h "@@RP-ENC:zb64"
    list [catch {Rappture::encoding::is encoded $h} msg] $msg
} {0 no}

test is-1.3.10 {Rappture::encoding::is, encoded with an embedded null} {
    list [catch {Rappture::encoding::is encoded "@@RP-ENC:zb64\nx\000x"} msg] $msg
} {0 yes}

#----------------------------------------------------------
#----------------------------------------------------------
# encode command
# Rappture::encoding::encode ?-as z|b64? ?-no-header? <string>
#----------------------------------------------------------

test encode-2.0.0 {Rappture::encoding::encode, 0 arguments} {
    list [catch {Rappture::encoding::encode} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::encode ?-as z|b64|zb64? ?-noheader? ?--? string"}}

test encode-2.1.0 {Rappture::encoding::encode, ascii string argument} {
    list [catch {Rappture::encoding::encode "hi"} msg] $msg
} {0 {@@RP-ENC:zb64
H4sIAAAAAAAAA8vIBACsKpPYAgAAAA==
}}

test encode-2.1.1 {Rappture::encoding::encode, binary string argument}  {
    set h "H4sIAAAAAAAAA8vIBACsKpPYAgAAAA=="
    set b [Rappture::encoding::decode -as b64 $h]
    list [catch {Rappture::encoding::encode $b} msg] $msg
} {0 {@@RP-ENC:zb64
H4sIAAAAAAAAA5Pv5mAAA+bTJ1gY1mhNvsEE5AAAFVLsvBYAAAA=
}}

test encode-2.2.0 {Rappture::encoding::encode, -as flag no value} {
    list [catch {Rappture::encoding::encode -as} msg] $msg
} {1 {value for "-as" missing}}

test encode-2.2.1 {Rappture::encoding::encode, -as flag bad value } {
    list [catch {Rappture::encoding::encode -as zz} msg] $msg
} {1 {bad value "zz": should be b64, zb64, or z}}

test encode-2.2.2 {Rappture::encoding::encode, -as flag correct value z} {
    list [catch {Rappture::encoding::encode -as z} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::encode ?-as z|b64|zb64? ?-noheader? ?--? string"}}

test encode-2.2.3 {Rappture::encoding::encode, -as z w/ string} {
    list [catch {Rappture::encoding::encode -as z "hi"} msg] $msg
} [list 0 "@@RP-ENC:z\n\037\213\010\000\000\000\000\000\000\003\313\310\004\000\254\052\223\330\002\000\000\000"]

test encode-2.2.4 {Rappture::encoding::encode, -as b64 w/ string} {
    list [catch {Rappture::encoding::encode -as b64 "hi"} msg] $msg
} {0 {@@RP-ENC:b64
aGk=
}}

test encode-2.2.5 {Rappture::encoding::encode with --} {
    list [catch {Rappture::encoding::encode -hi} msg] $msg
} {1 {unknown switch "-hi"
following switches are available:
   -as z|b64|zb64
   -noheader }}

test encode-2.2.6 {Rappture::encoding::encode with --} {
    list [catch {Rappture::encoding::encode -- -hi} msg] $msg
} {0 {@@RP-ENC:zb64
H4sIAAAAAAAAA9PNyAQA8jSeVgMAAAA=
}}

#----------------------------------------------------------
#----------------------------------------------------------
# decode command
# Rappture::encooding::decode <string>
#----------------------------------------------------------

test decode-3.0.0 {Rappture::encoding::decode, 0 arguments} {
    list [catch {Rappture::encoding::decode} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::decode ?-as z|b64|zb64? ?--? string"}}

test decode-3.1.0 {Rappture::encoding::decode, 1 arg, b64 encoded} {
    set h "aGk="
    list [catch {Rappture::encoding::decode $h} msg] $msg
} {0 aGk=}

test decode-3.1.1 {Rappture::encoding::decode, 1 arg, zb64 encoded} {
    set h "@@RP-ENC:zb64\nH4sIAAAAAAAAA8vIBACsKpPYAgAAAA=="
    list [catch {Rappture::encoding::decode $h} msg] $msg
} {0 hi}

test decode-3.1.2 {Rappture::encoding::decode, 2 args} {
    list [catch {Rappture::encoding::decode "hi" "bye"} msg] $msg
} {1 {wrong # args: should be "Rappture::encoding::decode ?-as z|b64|zb64? ?--? string"}}

test decode-3.2.0 {Rappture::encoding::decode, -as flag, no value} {
    list [catch {Rappture::encoding::decode -as} msg] $msg
} {1 {value for "-as" missing}}

test decode-3.2.1 {Rappture::encoding::decode, -as flag, bad value} {
    list [catch {Rappture::encoding::decode -as zz} msg] $msg
} {1 {bad value "zz": should be b64, zb64, or z}}

# This test is wrong.  The -as z flag should either 1) be ignored and return
# "hi" (using the header) or 2) override the header and return an error when
# attempting to decompress the bogus string (see 3.2.2b)

test decode-3.2.2 {Rappture::encoding::decode, -as flag, zb64 w/ string} {
    set h "@@RP-ENC:zb64\nH4sIAAAAAAAAA8vIBACsKpPYAgAAAA=="
    list [catch {Rappture::encoding::decode -as z $h} msg] $msg
} {0 {@@RP-ENC:zb64
H4sIAAAAAAAAA8vIBACsKpPYAgAAAA==}}

test decode-3.2.2b {Rappture::encoding::decode, -as -noheader, zb64 w/ string} {
    set h "@@RP-ENC:zb64\nH4sIAAAAAAAAA8vIBACsKpPYAgAAAA=="
    list [catch {Rappture::encoding::decode -as z -noheader $h} msg] $msg
} {1 {Rappture::Buffer::do_decompress()
:
memory error while inflating data
Rappture::Buffer::do_decompress()
}}

test decode-3.2.3 {Rappture::encoding::decode, -as flag, b64 w/ string} {
    set h "@@RP-ENC:b64\naGk="
    list [catch {Rappture::encoding::decode -as b64 $h} msg] $msg
} {0 hi}

test decode-3.2.4 {encode/decode reverse each other} {
    set msg "This is a test"
    Rappture::encoding::decode [Rappture::encoding::encode $msg]
} {This is a test}

test encode-3.2.5 {Rappture::encoding::decode with --} {
    list [catch {Rappture::encoding::decode -hi} msg] $msg
} {1 {unknown switch "-hi"
following switches are available:
   -as z|b64|zb64
   -noheader }}


test encode-3.2.6 {Rappture::encoding::decode with --} {
    list [catch {Rappture::encoding::decode -- -hi} msg] $msg
} {0 -hi}


::tcltest::cleanupTests
return

